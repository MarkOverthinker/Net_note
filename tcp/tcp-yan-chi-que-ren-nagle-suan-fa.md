---
description: 前者是为了提高ack传输效率，后者是减少小报文发送
---

# TCP延迟确认、nagle算法

小林链接

[https://xiaolincoding.com/network/3\_tcp/tcp\_tcpdump.html#tcp-%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4%E4%B8%8E-nagle-%E7%AE%97%E6%B3%95](https://xiaolincoding.com/network/3\_tcp/tcp\_tcpdump.html#tcp-%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4%E4%B8%8E-nagle-%E7%AE%97%E6%B3%95)

nagle算法：满足两个条件中的_**一个**_时才能发送报文：

* 窗口>= mss 且 数据大小 >= mss
* 收到ack

**Nagle 算法一定会有一个小报文，也就是在最开始的时候。没收到第一个小报文的确认不能发数据**

对于最后一个报文的思考：怎么知道是最后一个报文，也许是在要发送最后一个报文时主动关闭nagle，nagle是可以主动开启关闭的。



#### 延迟确认

事实上当没有携带数据的 ACK，它的网络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报文。

为了解决 ACK 传输效率低问题，所以就衍生出了 **TCP 延迟确认**。

TCP 延迟确认的策略：

* 当有响应数据要发送时，ACK 会随着响应数据一起立刻发送给对方
* 当没有响应数据要发送时，ACK 将会延迟一段时间，以等待是否有响应数据可以一起发送
* 如果在延迟等待发送 ACK 期间，对方的第二个数据报文又到达了，这时就会立刻发送 ACK



**当 TCP 延迟确认 和 Nagle 算法混合使用时，会导致时耗增长。因为nagle就导致延迟确认条件三可能不触发。**

发送方使用了 Nagle 算法，接收方使用了 TCP 延迟确认会发生如下的过程：

* 发送方先发出一个小报文，接收方收到后，由于延迟确认机制，自己又没有要发送的数据，只能干等着发送方的下一个报文到达；
* 而发送方由于 Nagle 算法机制，在未收到第一个报文的确认前，是不会发送后续的数据；
* 所以接收方只能等待最大时间 200 ms 后，才回 ACK 报文，发送方收到第一个报文的确认报文后，也才可以发送后续的数据。

